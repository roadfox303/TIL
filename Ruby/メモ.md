##### 複数行コメント
- =begin と =end で囲む。
- あまり使われない。

```
=begin
1行目のコメント
二行目のコメント
最後のコメントです。
=end

# 一行目
# 二行目のコメント
# 複数行コメントでもこっちのほうが主流です。
```

##### 数値の区切り文字
- 数値には _ を含める事ができる。
- 値には影響しない。

```
1_000_000_000 == 1000000000
#=> true
```

##### 整数同士の割り算は整数になる

```
1 / 2 #=> 0
1.0 / 2 #=> 0.5
1 / 2.0 #=> 0.5
```

##### 変数の整数を少数に変更できる
- to_f メソッド

```
n = 1
n.to_f #=> 1.0
n.to_f / 2 #=> 0.5
```
##### %記法
- \ でエスケープしなくてもクォートを表示できる。

```
puts %q!He said "Don't speak" (%qはシングルクオートで囲むのと同じ)
puts %Q!He said "Don't speak" (%Qはダブルクオートで囲むのと同じ)
puts %q?He said "Don't speak" (!でなくても任意の記号を区切り文字として使える)
puts %q{He said "Don't speak"} (カッコを区切り文字にする場合は、閉じも必要)
```

- 簡単に文字列の配列を作れる

```
%w(apple melon orange)
#=> ["apple", "melon", "orange"]
```

##### 三項演算子
- if を下記のように短縮する事ができる。
- 複雑な条件だとかえって読みづらい場合もあるので、可読性を考慮して使うこと。

```
n = 11
n > 10 ? '10より大きい':'10以下'
```

```
# 上記はこれと同じ
n = 11
if n > 10
  '10より大きい'
else
  '10以下'
end
```

##### ? で終わるメソッド
- ブーリアンで値を返すメソッドは ? で終わらせる方が分かりやすくてよい。

```
# 例)
# 3の倍数ならtrue、それ以外はfalseを返す。
def multiple_of_three?(n)
  n % 3 == 0
end

multiple_of_three?(4) #=> false
multiple_of_three?(6) #=> true
```

##### オブジェクトの参照
- ruby は変数を他の変数代入したり、メソッドの引数として渡すと、元の変数と同じオブジェクトへの参照を渡す。
- つまりは、参照元のオブジェクト（変数）の値を変更すると、参照する値も変わってしまう。

```
a = 'hello'
b = 'hello'

a.object_id #=> 7018638956400
b.object_id #=> 7018638956960

c = b
c.object_id #=> 7018638956960

b.upcase! #=> 'HELLO'
c #=> 'HELLO'
a #=> 'hello'

```

##### require_relative (相対パスで require)
- require は Rubyを実行しているディレクトリを起点になる。
- require_relative で読み込みをすると、その requireを記述したファイルが起点の相対パスで読み込める。
```
# 一階層戻って、hoge の fuga.rb を読み込む
require_relative '../hoge/fuga'
```

##### puts, print, p メソッドの違い
|メソッド|出力後の改行|配列の表示|呼び出すメソッド|戻り値|対象者|
|:---:|:---:|:---:|:---:|:---:|:---:|
|puts|あり|要素ごとに改行|to_s|nil|一般ユーザー|
|print|なし|改行しない|to_s|nil|一般ユーザー|
|p|あり|改行しない|inspect|引数のオブジェクト|開発者|

##### minitest
```
require 'minitest/autorun'

class SampleTest < Minitest::Test
  def test_sample
    assert_equal 'RUBY', 'ruby'.upcase
  end
end

# assert_equal 期待する結果,テスト対象となる値や式
```

- よく使う検証メソッド

```
# a と b が等しければパス
assert_equal b, a

#a が真ならパス
asset a

#a が偽ならパス
refute a
```

##### divmod
- 割った商と余を多重代入で返す

```
14.divmod(3) #=> [4, 2]
```

##### delete メソッド (配列から条件に当てはまる値を削除する)
- delete：引数の値を削除
- delete_if：ブロックの処理結果が true なら削除する。

```
a = [1,2,3,1,2,3]
a.dalete(2) #=> [1,3,1,3]

a = [1,2,3,1,2,3]
a.dalete_if do |n|
  n.odd?
end
#=>[2,2]

```

##### select / find_all / reject
- 配列の各要素に対しブロックを評価し、戻り値が true の要素だけを集めた配列を返すメソッド。

```
numbers = [1,2,3,4,5,6]
even_numbers = numbers.select { |n| n.even? }
even_numbers #=> [2,3,6]
```

##### inject
- たたみこみ演算を行う。eachなどのように配列の要素を次々とブロックに渡し、合算(足し算に限らない)していく感じ
- 初回のみブロックの第一引数には、メソッドの引数で渡された値が入る。

```
numbers = [1,2,3,4]
sum = numbers.inject(0) { |result,n| result + n }

# 初回のみ result にはメソッドの引数で渡された 0 が入る。
# 1回目のループ：result = 0, n = 1で、 0 + 1 = 1 。これが次の result に入る。
# 2回目のループ：result = 1, n = 2で、 1 + 2 = 3 。これが次の result に入る。
# 3回目のループ：result = 3, n = 3で、 3 + 3 = 6 。これが次の result に入る。
# 4回目のループ：result = 6, n = 4で、 6 + 4 = 10 。最後の要素に達したので inject の戻り値となる。
# ((((0 + 1) + 2) + 3) + 4) と同じ
```

##### rjust
- 値を右寄せにする。
- 第一引数で何桁右に寄せるか、第二引数で空いた桁を埋める文字を指定する。
```
'0'.rjust(5) #=> "    0"
'0'.rjust(5,'0') #=> "00000"
'0'.rjust(5,'9') #=> "99990"
```

##### 配列の要素取得
- 配列の取り出しは複数桁一気に取れる

```
a = [1, 2, 3, 4, 5]
a[1, 3]
#=> [2, 3, 4]
```

```
a = [1, 2, 3, 4, 5]
a.values_at(0, 2, 4)
#=> [1, 3, 5]
```

##### 配列の和集合、差集合、積集合
- 和集合
```
# 左の配列と右の配列を、重複を無くして統合する
a = [1, 2, 3]
b = [4, 5, 6]
a | b #=> [1, 2, 3, 4, 5]
```

- 差集合
```
# 左の配列から右の配列に含まれる要素を取り除く
a = [1, 2, 3]
b = [4, 5, 6]
a - b #=> [1, 2]
```

- 積集合
```
# 左の配列と右の配列で共通する要素だけを返す。
a = [1, 2, 3]
b = [4, 5, 6]
a & b #=> [3]
```

- |、-、&、これらはいずれも非破壊的であり、元の配列は変更しない。

##### 多重代入

```
e, f = 100, 200, 300
e #=> 100
f #=> 200

# 代入する変数が足りないので 300 は切り捨てられる
```

```
e, *f = 100, 200, 300
e #=> 100
f #=> [200, 300]

# 左辺の配列に * をつけると残りの全要素を配列として受け取る。
```

##### 配列の要素をを複数の引数として扱う

```
a = []
b = [2,3]

a.push(1) #=> [1]
a.push(b) #=> [1,[2,3]]

# 普通はこうなってしまうが

a = []
b = [2,3]

a.push(1) #=> [1]
a.push(*b) #=> [1,2,3]

# * をつけることで、複数の引数として渡されこうなる。
```

```
a = [1, 2, 3]
[-1, 0, *a, 4, 5]
#=> [-1, 0, 1, 2, 3, 4, 5]

# 応用するとこのように次元を揃えた新しい配列を作る事が可能
```

##### with_index
- ブロックの第二引数に添字(配列番号)を付加する。
- each以外にも、mapなどブロックに値を渡すタイプのループ処理系メソッドで使える。
- 添字を0以外からスタートさせることもできる。

```
fruits = ['apple','orange','melon']
fruits.each.with_index { |fruit, i| puts "{#i}: #{fruit}"}
#=> 0: apple
#=> 1: orange
#=> 2: melon
```
```
# 添字を指定の値からスタートする場合
fruits = ['apple','orange','melon']
fruits.each.with_index(5) { |fruit, i| puts "{#i}: #{fruit}"}
#=> 5: apple
#=> 6: orange
#=> 7: melon
```
